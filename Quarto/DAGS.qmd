---
title: "DAGS"
author: 
  - name: "Jose Angel Govea Garcia"
  - name: "Diego Vértiz Padilla"
  - name: "Daniel Sánchez Fortiz"
  - name: "Augusto Ley Rodriguez"
format:
  html:
    toc: true
    html-math-method: katex
    embed-resources: true
    self-contained-math: true
    df-print: kable
editor: source
---

Instalamos la librerias que vamos a utilizar

```{r}
#install.packages("tidyverse")

```

Cargamos las librerias que utilizaremos.

```{r}
library(tidyverse)
library(bnlearn)
```

```{r}
library(dplyr)
```

Aqui vamos a cargar los datos que utilizaremos (que son los limpios)

```{r}
data = read_csv("../data_ensanut/datos2.csv")
head(data)
```

Ya teniendo la opinión de los expertos solo utilizaremos las variables que nos dieron.

Es por eso que vamos a seleccionar las que necesitaremos.

Pero primero vamos a ver los nombres de las variables que tenemos

```{r}
colnames(data)
```

Ahora si ya tengo mis 17 variables que usaré. Creamos una lista de las variables a utilizar para crear el data de esas variables.

```{r}
vars_usar <- c("desc_ent", "desc_mun", "estrato", "h0302", "h1205", "NOx",
               "COV", "SO_2", "nota03", "valor_COLEST", "valor_TRIG",
               "valor_FERRITINA", "valor_FOL", "valor_HCST","valor_CREAT", "valor_AC_URICO", "valor_HB1AC")
```

creamos un dataframe con solo las variables a usar

```{r}
datos_buenos <- data[, vars_usar]
```

Vemos que se creó correctamente.

```{r}
head(datos_buenos)
```

Ahora como hay algunas observaciones que tienen NA vamos a dropearlas por que el modelo no me permite tener NA

```{r}

datos_ <- na.omit(datos_buenos)
head(datos_)

```

Vamos a contar cuantas columnas tienen NA

```{r}
colSums(is.na(datos_))
```

Perfecto ya no hay ningun na, ahora lo que haremos es cambiar el nombre de las variables (columnas) para que sean mas fáciles de manejar. E = Entidad M = Municipio ES = Estrato S = Sexo C19 = Covid 19 NO = Nivel NOx CO = Nivel de COv SO = Nivel de S0_2 MN = Micornutrimentos C = Colesterol Total T = Trigliceridos F = valor de Ferritina FO = Valor de Fol H = Valor de HCST CT = Valor de Creatinina AC = Valor de Ácido Úrico HB = Valor de Hemoglobina Glucosilda

```{r}
colnames(datos_) = c("E", "M", "ES", "S", "C19", "NO","CO", "SO", "MN", "C", "T", "F", "FO", "H", "CT", "AC", "HB")
```

Revisamos que si se hayan cambiando los nombre de las variables.

```{r}
head(datos_)
```

Ahora revisamos que informacion contiene la variable de Covid (C19).

```{r}
unique(datos_$C19)
```

Ahora como la varible C19 se significa cuantas veces ha tenido covid desde el 2020. Esta variable nos arroja 1, 2,3 ,4, 98 y 99. Estos se significa 1 = ha tenido una vez covid desde el 2020, 2 = ha tenido 2 veces covid desde el 2020, 3 = ha tenido 3 veces covid desde el 2020, 4 = ha tenido covid 4 veces desde el 2020, 98 = no ha tenido covid desde el 2020, 99 = no recuerda / no contestó. Entonces lo que haremos es estandarizar esta variable, si la variable es 1,2,3,4 = 1 (si ha tenido covid) y si la variable es 98 ,99 = 0 (no ha tenido covid). Esto para facilitar la dag.

```{r}
datos_ <- datos_ %>%
  mutate(C19 = case_when(
    C19 %in% c(1,2,3,4) ~ 1,   
    C19 %in% c(98,99)   ~ 0, ))

```

```{r}
head(datos_)
```

Checamos los valores de la variables C19

```{r}
unique(datos_$C19)
```

Ahora lo que haremos es como CT (Valor de creatinina) son caracteres. por lo tanto, lo convertimos a numericas.

```{r}
datos_ <- datos_ %>%
  mutate(CT = as.numeric(str_replace(CT, ",", "\\.")))
```

Checamos que si se haya remplazado:

```{r}
head(datos_)
```

Luego vamos a dropear la columnas de E (Entidad), M (Municipio), S (Sexo), ES(Estrato) C19 (Covid) y el MN (Micronutrimentos). Esto por que no son Continuas. Luego las utilizaremos en otras DAGS

```{r}

data = datos_ |>
        select(-E,-M, -C19, -MN, -ES, -S)

```

```{r}
head(data)
```

Nos quedaremos con las siguientes, temporalmente.

```{r}
colnames(data)
```

# Creación de DAGS

```{r}
dag1 <- model2network("[NO][CO][SO][CT|NO:CO:SO][AC|NO:CO:SO:CT][HB|NO:SO][F|NO:CO:SO:HB][T|HB:AC:F][C|HB:AC:F][FO][H|NO:CO:SO:FO]")

```

```{r}
graphviz.plot(dag1, shape = "ellipse")
```

```{r}
dag2 <- model2network("[NO][CO][SO][HB|NO:CO:SO][AC|NO:CO:SO][H|NO:CO:SO:FO][FO][F|CT][CT|NO:SO][T|HB:AC][C|HB:AC]")


```

```{r}
graphviz.plot(dag2, shape = "ellipse")

```

```{r}
dag3 <- model2network("[NO][CO][SO][H|NO:CO:SO:FO][FO][F|SO][CT|NO:CO:SO][AC|H:CT][HB|NO:SO][T|HB:AC][C|HB:AC]")
```

```{r}
graphviz.plot(dag3, shape = "ellipse")
```

Comparamos las DAGs dados sus scores:

```{r}
library(dplyr)
library(purrr)

dags <- list(dag1 = dag1, dag2 = dag2, dag3 = dag3)

tibble(
  DAG = names(dags),
  BICg = map_dbl(dags, ~ score(.x, data = data, type = "bic-g")),
  AICg = map_dbl(dags, ~ score(.x, data = data, type = "aic-g")),
  BGe  = map_dbl(dags, ~ score(.x, data = data, type = "bge"))
)
```

Al comparar los scores de las tres DAGs propuestas por los expertos, se calculó tanto el BICg como el AICg (criterios de información para distribuciones gaussianas, implementados en bnlearn). Los resultados muestran que la DAG 3 alcanza el mejor desempeño, con los valores más altos (menos negativos) en ambos criterios, superando a las DAGs 1 y 2. Por lo tanto, se selecciona la DAG 3 como la estructura más adecuada para continuar el análisis.

Adicionalmente, este tipo de comparación puede complementarse con otros métodos, como el BGe score (Bayesian Gaussian equivalent), disponible en bnlearn para redes gaussianas. Este criterio es de naturaleza bayesiana y ofrece una alternativa al BICg/AICg, pudiendo reportarse de manera similar para reforzar la robustez de la selección del modelo.

# Inclusion Variables Categoricas

Vamos a incluir el sexo y el estrato, por lo que dropearemos las mismas varibales que antes menos estas 2

```{r}

data_cat = datos_ |>
        select(-E,-M, -C19, -MN)

```

```{r}
head(data_cat)
```

```{r}
data_cat$ES <- factor(sample(1:3, nrow(data_cat), replace = TRUE), labels = c("Rural", "Urbano", "Metropolitano"))
data_cat$S <- factor(sample(1:2, nrow(data_cat), replace = TRUE), labels = c("Hombre", "Mujer"))
```

```{r}
# Convertir las variables 'ES' y 'S' a factor
data_cat$ES <- as.factor(data_cat$ES)
data_cat$S <- as.factor(data_cat$S)
data_cat$NO <- as.numeric(data_cat$NO)
data_cat$CO <- as.numeric(data_cat$CO)
data_cat$SO <- as.numeric(data_cat$SO)
data_cat$C <- as.numeric(data_cat$C)
data_cat$T <- as.numeric(data_cat$T)
data_cat$F <- as.numeric(data_cat$F)
data_cat$FO <- as.numeric(data_cat$FO)
data_cat$H <- as.numeric(data_cat$H)
data_cat$CT <- as.numeric(data_cat$CT)
data_cat$AC <- as.numeric(data_cat$AC)
data_cat$HB <- as.numeric(data_cat$HB)

# Puedes revisar el tipo de cada columna para confirmarlo
str(data_cat)
```

```{r}
dag_cat <- model2network("[S][ES][NO][CO][SO][H|NO:CO:SO:FO:ES:S][FO][F|SO][CT|NO:CO:SO][AC|H:CT][HB|NO:SO][T|HB:AC][C|HB:AC:ES:S]")
```

```{r}
#fitted_model <- bn.fit(dag_cat, data = data_cat)
```

```{r}
graphviz.plot(dag_cat, shape = "ellipse")
```

```{r}
data_g <- as.data.frame(data)
fit <- bn.fit(dag3, data = data_g, method= "mle-g")
```

```{r}
fit
```

```{r}
library(mgcv)
mod_NO = lm(NO ~ 1, data = data)
mod_CO = lm(CO ~ 1, data = data)
mod_SO = lm(SO ~ 1, data = data)
mod_FO = lm(FO ~ 1, data = data)
# H | NO, CO, SO, FO
mod_gam_H  <- gam(H  ~ s(NO) + s(CO) + s(SO) + s(FO), data = data_g, method = "REML")

# F | SO
mod_gam_F  <- gam(F  ~ s(SO), data = data_g, method = "REML")

# CT | NO, CO, SO
mod_gam_CT <- gam(CT ~ s(NO) + s(CO) + s(SO), data = data_g, method = "REML")

# AC | H, CT
mod_gam_AC <- gam(AC ~ s(H)  + s(CT), data = data_g, method = "REML")

# HB | NO, SO
mod_gam_HB <- gam(HB ~ s(NO) + s(SO), data = data_g, method = "REML")

# T | HB, AC
mod_gam_T  <- gam(T  ~ s(HB) + s(AC), data = data_g, method = "REML")

# C | HB, AC
mod_gam_C  <- gam(C  ~ s(HB) + s(AC), data = data_g, method = "REML")

mod_lm_H  <- lm(H  ~ NO + CO + SO + FO, data = data_g)
mod_lm_F  <- lm(F  ~ SO,                data = data_g)
mod_lm_CT <- lm(CT ~ NO + CO + SO,      data = data_g)
mod_lm_AC <- lm(AC ~ H  + CT,           data = data_g)
mod_lm_HB <- lm(HB ~ NO + SO,           data = data_g)
mod_lm_T  <- lm(T  ~ HB + AC,           data = data_g)
mod_lm_C  <- lm(C  ~ HB + AC,           data = data_g)

aic_comp <- data.frame(
  nodo = c("H","F","CT","AC","HB","T","C"),
  AIC_GAM = c(AIC(mod_gam_H), AIC(mod_gam_F), AIC(mod_gam_CT),
              AIC(mod_gam_AC), AIC(mod_gam_HB), AIC(mod_gam_T), AIC(mod_gam_C)),
  AIC_LM  = c(AIC(mod_lm_H),  AIC(mod_lm_F),  AIC(mod_lm_CT),
              AIC(mod_lm_AC), AIC(mod_lm_HB),  AIC(mod_lm_T),  AIC(mod_lm_C))
)
aic_comp$mejor <- ifelse(aic_comp$AIC_GAM < aic_comp$AIC_LM, "GAM", "LM")
aic_comp
```

### Query 1: Dislipidemia

¿Cuando los niveles de un contaminante (NO, CO o SO) son altos, aumenta la probabilidad de que una persona presente **colesterol o triglicéridos elevados**?

```{r}
"p_dislip_NO <- p_cond( (C > thrC) | (T > thrT), NO > thrNO )
p_dislip_CO <- p_cond( (C > thrC) | (T > thrT), CO > thrCO )
p_dislip_SO <- p_cond( (C > thrC) | (T > thrT), SO > thrSO )"
```

### Query 2

¿Cuando aumentan los niveles de cierto contaminante, se observa mayor necesidad de atención médica relacionada con el corazón y la circulación?

```{r}

```

### Query 3

¿Cuando aumentan los niveles de cierto contaminante, se observa mayor necesidad de atención médica relacionada con el corazón y la circulación?

```{r}

```
